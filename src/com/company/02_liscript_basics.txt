(defmacro show-ex (e) (print " ?  " (quote e) \n " =  " e \n))

(defmacro pause () (print \n "(Ctrl+Enter): ") (read))

(print "
Основные сведения о языке Liscript.

Язык является представителем Lisp-семейства, в данной программе реализована его интерпретируемая версия со строгим порядком вычисления выражений. В язык постоянно вносятся изменения, порой радикальные, так что настоящее описание может не соответствовать текущим свойствам и возможностям языка.

Общая концепция данного семейства языков - вычисление списков. Сначала вычисляется первый элемент. Если результат вычисления - операция над базовыми типами, особая форма языка, функция или макрос - то весь список вычисляется по правилам этой операции. В остальных случаях строго последовательно вычисляются все элементы списка и в качестве результата возвращается последнее значение.
")
(pause)

(print "
Базовые элементарные типы.
Любое выражение Liscript является значением одного из конечного набора типов языка. Для определения типа выражения в ядре языка реализована особая формы - typeof, возвращающая строковое представление типа. На основе этой формы в стандартной библиотеке определены макросы, возвращающие истину при соответствующем типе выражения: list?, func? и т.д. 
    
")
(show-ex (typeof true))
(show-ex (typeof 1))
(show-ex (typeof 1.0))
(show-ex (typeof "abc"))
(show-ex (typeof (+ 1 2 3)))
(show-ex (typeof map))
(show-ex (typeof defn))
(show-ex (typeof qwszarcweatbSERYRMB24ARWQ25))
(pause)

(print "
Числа.
Целые (тип Integer в платформе реализации) и с плавающей точкой (Double). При арифметических операциях целые числа автоматически расширяются до плавающей точки если один из операндов имеет данный тип. Операции:

    +  -  *  /  mod
    >  >=  <  <=  =  /=

")
(show-ex (+ 1 2 3))
(show-ex (+ 1 2.0 3))
(show-ex (+ 1 2 (+ 3 1E10)))
(pause)

(print "
Строки.
Пока всего одна операция - конкатенация:

    ++

При вычислении приводит аргументы к строковому представлению:

")
(show-ex (++ "'" 1 "абв" "где" '(1 2 3) "'"))
(pause)

(print "
Особые формы ядра языка.
Многие из них полиарны - допускают передачу ряда параметров и/или работают не совсем так, как их одноименные аналоги в других диалектах Lisp (см. примеры):

    eq? : проверка равенства всех переданных объектов

    def, set!, get : создание/изменение/получение значений

    cons, car, cdr : конструктор и геттеры списка

    typeof : определяет тип выражения 
    quote  : оператор цитирования
    cond   : многокейсовый условный оператор
    while  : оператор цикла
    eval   : вычислитель выражения
    
    read, print : ввод/вывод

    lambda : конструктор функции
    macro  : конструктор макроса
")
(pause)

(print "
Примеры - eq?, def, set!, get:

")
(show-ex (eq? "абв" "абв" (++ "а" "б" "в")))
(show-ex (def a1 1 b1 (+ a1 1) (++ "c" a1) (+ a1 b1)))
(show-ex (++ "a1 = " a1 ", b1 = " b1 ", c1 = " c1))
(show-ex (set! (++ "a" 1) 5 c1 10))
(show-ex (++ "a1 = " a1 ", b1 = " (get (++ "b" 1)) ", c1 = " c1))
(show-ex ((def div-tmp / / *) "И мы потеряли деление"))
(show-ex (/ 100 2))
(show-ex ((def / div-tmp) "Восстановим деление"))
(show-ex (/ 100 2))
(pause)

(print "
Примеры - cons, car, cdr:

")
(show-ex (def a (cons 1 2 3)))
(show-ex a)
(show-ex (cons a 4))
(show-ex (cons 0 a))
(show-ex (cons 0 a nil))
(show-ex (car a))
(show-ex (car 5))
(show-ex (car '()))
(show-ex (cdr a))
(show-ex (cdr 5))
(show-ex (cdr '()))
(pause)

(print "
Примеры - cond, while, eval, lambda, macro:

")
(show-ex (def f (lambda (x) (cond (< x 0) -1 (> x 0) 1 0))))
(show-ex (cons (f -100) (f 100.5) (f 0)))
(show-ex ((def i 0) (while (< i 5) (print i ", ") (set! i (+ 1 i)))))
(show-ex (eval (cons + (quote (1 2 3)))))
(show-ex (def m (macro (i r) (cond (<= i 0) 'r (m (- i 1) (cons i r))))))
(show-ex (m 5 nil))
(show-ex (eval (m 5 nil)))
(pause)

(print "
Примеры - read:

")
(show-ex (def read-int (lambda ()
    (print "Введите целое число: ")
    (def n (read))
    (cond (eq? "Integer" (typeof n)) n (read-int)))))
(show-ex ((def n (read-int)) (++ "Удвоим введенное число: " (* 2 n))))
(pause)

(print "
Функции.
Конструируются особой формой lambda (или макросом defn, определенном с использованием lambda в стандартной библиотеке). Реализована автоматическая оптимизация хвостовых вызовов - ТСО. При создании функция захватывает текущий контекст. При применении аргументы вычисляются строго последовательно, связываются с именами формальных параметров функции в отдельном окружении, подчиненном захваченному функцией контексту, и в этом окружении вычисляется тело функции.

Примеры ТСО:

")
(show-ex (defn is-even (n) (cond (= n 0) true  (is-odd  (- n 1)) )))
(show-ex (defn is-odd  (n) (cond (= n 0) false (is-even (- n 1)) )))
(show-ex (is-even 10000))
(show-ex (is-even 10001))
(show-ex (defn go (n a) (cond (<= n 0) a (go (- n 1) (+ n a)) )))
(show-ex (go 10000 0))
(pause)

(print "
Если аргументов передано больше, чем формальных параметров функции, то последний формальный параметр свяжется со списком вычисленных оставшихся переданных аргументов. Если меньше - то эти формальные параметры окажутся не связаны в окружении вычисления функции и при вычислении ее тела будут искаться в окружениях верхнего уровня иерархии. Это не считается ошибкой, но надо аккуратно использовать этот механизм.

")
(show-ex ((defn f (a b) (++ "a = " a ", b = " b)) (f 1 2 3 4 5)))
(show-ex (def s "Global "))
(show-ex (defn f (i s) (cond (< i 1) "end" (++ s (f (- i 1))))))
(show-ex (f 3 "local "))
(show-ex (defn g (i a s) (cond (< i 1) a (g (- i 1) (++ s a)))))
(show-ex (g 3 "end" "local "))
(pause)

(print "
Макросы.
Liscript поддерживает так называемые runtime-макросы, которые являются объектами первого класса языка. Их можно создавать, связывать с именами, возвращать как результат функций и выполнять в процессе работы (интерпретации кода). Полученное из текста исходного кода выражение сразу начинает интерпретироваться, без предварительной стадии раскрытия макросов, поэтому макросы остаются полноправными типами языка и раскрываются и вычисляются в процессе интерпретации по всем правилам вычисления макросов - сначала производится подстановка в тело макроса невычисленных переданных аргументов а затем это тело макроса вычисляется в текущем окружении (в отличие от тела функции, которое всегда вычисляется в отдельном собственном окружении, в котором уже присутствуют предварительно вычисленные значения фактических параметров).

")
(show-ex (def m (macro  (x) (++ 'x " = " x))))
(show-ex (m (+ 1 2)))
(show-ex (def f (lambda (x) (++ 'x " = " x))))
(show-ex (f (+ 1 2)))

"
Вот вкратце и все описание языка. Набор часто используемых определений, функций и макросов реализован посредством стандартной библиотеки, которая автоматически подгружается из файла при старте приложения. Можно посмотреть ее код и при желании добавить или изменить ее содержание. То же касается кода этого и других демо примеров."
